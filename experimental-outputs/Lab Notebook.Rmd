---
title: "Lab notebook"
author: "KBC"
date: "4/5/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggVennDiagram)

DEBUG <- FALSE
```

## 2021-04-05 report


## Utility functions

```{r, echo = FALSE}
# arguments:
# an ontology object
# a list of IDs to look up and print the corresponding terms
print_opposites <- function(this.ontology, opposite.ids) {
  for (i in 1:nrow(opposite.ids)) {
    opposites <- opposite.ids[i,]
    id01 <- as.character(opposite.ids[1])
    id02 <- as.character(opposite.ids[2])
    term01 <- get_term_property(this.ontology, property = "name", term = id01)
    term02 <- get_term_property(this.ontology, property = "name", term = id02)
    print(paste(term01, term02, sep = "     "))
  }
} # close function definition print_opposites
  
```


## Opposites already manually paired 

Bill can explain where these came from better than I can.

```{r, echo = FALSE, eval = FALSE}

# NB: need to add reduce/increase. Do HP, then RO.

# only found by me
# comm -23 experimental-outputs/pato.mine.terms.only.tsv resources/current-opposites.sorted.terms.only.tsv | wc -l
#      59

# only in current annotations
#comm -13 experimental-outputs/pato.mine.terms.only.tsv resources/current-opposites.sorted.terms.only.tsv | wc -l
#      27


# in both
#comm -12 experimental-outputs/pato.mine.terms.only.tsv resources/current-opposites.sorted.terms.only.tsv | wc -l
#     188

# https://www.datanovia.com/en/fr/blog/magnifique-diagramme-de-venn-ggplot-avec-r/

# this separates out the three entirely--not what the ggVennDiagram() function is looking for
# Here I'm just getting the terms themselves in printable fashion, separating them by who "finds" them
pato.mine.only <- as.vector(read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/pato.in.mine.txt"))
pato.mine.only <- stringr::str_split(pato.mine.only, pattern = "\t")
#pato.mine.only
current.only <- as.vector((read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/pato.in.current.txt")))
current.only <- stringr::str_split(current.only, pattern = "\t")
both.mine.and.current <- as.vector((read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/pato.in.both.txt")))
both.mine.and.current <- stringr::str_split(both.mine.and.current, pattern = "\t")

# here I have *everything* that I found and *everything* in current, so that we can quantify overlap & lack thereof
pato.mine <- as.vector(read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/pato.mine.terms.only.tsv"))
current <- as.vector(read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/resources/current-opposites.sorted.terms.only.tsv")) # includes two non-PATO terms

x <- list(Mine = pato.mine, Current = current)
ggVennDiagram(x)

print("IN BOTH MINE AND THE CURRENT PAIRS:")
#print(both.mine.and.current, row.names = FALSE)
for (i in 1:length(both.mine.and.current)) { print(both.mine.and.current[[i]])}
print("")

print("IN MINE ONLY:") 
for (i in 1:length(pato.mine.only)) { print(pato.mine.only[[i]])}
print("")

print("IN THE CURRENT PAIRS ONLY:")
for (i in 1:length(current.only)) { print(current.only[[i]])}




```


## Comparison to Chris et al.'s stuff

```{r, echo = FALSE, eval = FALSE}
chris <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/mungall_both_hp.tsv", header = FALSE, sep = "\t")
colnames(chris) <- c("term01", "term02")
chris <- as_tibble(chris)
hp.mine <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/hp_opposites_ids_only.tsv", header = FALSE, sep = "\t")
colnames(hp.mine) <- c("term01", "term02")
hp.mine <- as_tibble(hp.mine)

# Reran my stuff on HPO 2021-04
chris.as.vector <- as.vector(paste(chris$term01, chris$term02))
hp.mine.as.vector <- as.vector(paste(hp.mine$term01, hp.mine$term02))
x <- list(Mine = hp.mine.as.vector, Chris = chris.as.vector)
ggVennDiagram(x)

print("Mine:")
print(hp.mine)
print("Chris's:")
print(chris)
```
OK, we know the intersection/complements, so let's see what Chris's opposites look like, exactly.

```{r, echo = FALSE, eval = FALSE}
library(ontologyIndex)
# His data is IDs only, and we need the terms, so we need to have a searchable version of HPO.
hpo.ontology <- get_ontology("/Users/kevincohen/Dropbox/a-m/Corpora/obo/hp-2020-20-12.obo")

# REDUNDANT, I THINK??
# for (i in 1:nrow(chris)) {
#   #print(chris[i,])
#   opposites <- chris[i,]
#   id01 <- as.character(opposites[1])
#   id02 <- as.character(opposites[2])
#   term01 <- get_term_property(hpo.ontology, property = "name", term = id01)
#   term02 <- get_term_property(hpo.ontology, property = "name", term = id02)
#   print(paste(term01, term02, sep = "     "))
#   # term01 <- chris[i,]
#   # term02 <- chris[i,]
# }

intersection.ids <- intersect(hp.mine, chris)
if (DEBUG) { print(intersection.ids) }

print("FOUND BY BOTH ME AND CHRIS:")
for (i in 1:nrow(intersection.ids)) {
  opposites <- intersection.ids[i,]
  id01 <- as.character(opposites[1])
  id02 <- as.character(opposites[2])
  term01 <- get_term_property(hpo.ontology, property = "name", term = id01)
  term02 <- get_term_property(hpo.ontology, property = "name", term = id02)
  print(paste(term01, term02, sep = "     "))
}

mine.only.ids <- setdiff(hp.mine, chris)
chris.only.ids <- setdiff(chris, hp.mine)

# TODO: could make term-only tibbles here
print("FOUND BY ME, NOT BY CHRIS:")
print("")
for (i in 1:nrow(mine.only.ids)) {
  opposites <- mine.only.ids[i,]
  id01 <- as.character(opposites[1])
  id02 <- as.character(opposites[2])
  term01 <- get_term_property(hpo.ontology, property = "name", term = id01)
  term02 <- get_term_property(hpo.ontology, property = "name", term = id02)
  print(paste(term01, term02, sep = "     "))
}

print("FOUND BY CHRIS, NOT BY ME:")
print("")
for (i in 1:nrow(chris.only.ids)) {
  opposites <- chris.only.ids[i,]
  id01 <- as.character(opposites[1])
  id02 <- as.character(opposites[2])
  term01 <- get_term_property(hpo.ontology, property = "name", term = id01)
  term02 <- get_term_property(hpo.ontology, property = "name", term = id02)
  print(paste(term01, term02, sep = "     "))
}


```

## RO exploration 

I extracted the terms from the current version of the RO, then got the absolute frequencies of their words:

_/Users/kevincohen/Dropbox/Scripts-new/lexicalFrequency.pl experimental-outputs/ro.terms.txt
_

...which reveals imbalances in the use of words that are clear opposites, e.g.:

* during	11 before	4 after	2
* to	49 from	16 towards	1 _how about away?_
* directly	18 indirectly	8
* indirect	2 direct	2

...which suggests that I could be adding a bunch of opposite terms to the ontology.

So, I ran the current version of my antonym-finding script:

_code/findAntonyms.pl resources/ontologies/ro.2021-03-08.obo.txt |wc -l _

...which finds 43 pairs of opposites.

Next step: find overlap with Mike's resources/ontologies/predicates.txt.

## For next weeks...

0. With Bill, reorganize repository and merge with TRANSLATOR's
1. Test cases in human-readable form
2. Handle substitutions (e.g. hypercalcemia vs. hypocalcemia)
3. Suffixes (e.g. hydrophilic vs. hydrophobic)
4. Word-internal, possibly (might produce a lot of false positives later when we do generation)

## 2021-04-15 report

### Analysis of PATO opposites WRT the excluded middle

Motivation: this picks out a specific type of opposition: what Pustejovsky calls _polar_, meaning that there's a scale and the things at the two poles of the scale are opposites of each other.

### How I assigned the excluded.middle value

0. If the middle is reasonably clearly excluded, I assigned the value _yes_. Examples: _acute/chronic, aerobic/anaerobic_. If that is not the case, then I put the "middle" value in the excluded.middle field. Example: for _phosphorylated/dephosphorylated_, I put the value _unphosphorylated_ in the excluded.middle column.

1. Almost every pair that fits the pattern _increased/decreased x_ has a mid-point or neutral point _normal x_.
2. Most pairs of the form _x/unx_ (e.g. _responsive/unresponive_) exclude the middle. Exception: _damaged/undamaged/repaired_.
3. Most pairs of the form _x/dex_ (e.g. _phosphorylated/dephosphorylated_) have a neutral point _unx_ (e.g. _unphosphorylated_). 
4. Most pairs of the form _hypox/hyperx_ where both members of the pair are single words have a single-word neutral point _normox_. For example, for the pair _hypotrophic/hypertrophic_, there is a neutral point _normotrophic_. If I had any question about the legitimacy of these, I checked Google Scholar to ensure that the _normox_ word is used.
5. If I did not find such a word via Google Scholar, then I searched for the phrase _neither term01 nor term02_. If I found it, then I put the phrase in the field. (TODO: now that I think about it, if I didn't find the phrase, I didn't try again with the order _term02 term01_. Need to do that.)

```{r, eval = FALSE}
# "current" is the ones that Bill found currently in use
in.both <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/typed.opposites.pato.in.both.txt", header = TRUE, sep = "\t")
in.mine.only  <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/typed.opposites.pato.in.mine.txt", header = TRUE, sep = "\t")
in.current.only <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/typed.opposites.pato.in.current.txt", header = TRUE, sep = "\t")

in.both$excluded.middle <- as.character(in.both$excluded.middle)
in.mine.only$excluded.middle <- as.character(in.mine.only$excluded.middle)
in.current.only$excluded.middle <- as.character(in.current.only$excluded.middle)
# in.both <- as_tibble(in.both)
# in.both <- mutate(in.both, found.by = "BOTH")
# in.mine.only <- as_tibble(in.mine.only)
# in.mine.only <- mutate(in.mine.only, found.by = "ME")
# in.current.only <- as_tibble(in.current.only)
# in.current.only <- mutate(in.current.only, found.by = "CURRENT")
 
# in.combined <- as_tibble(in.both, in.mine.only, in.current.only)

#ggplot(data = in.combined, mapping = aes(x = found.by, )) +
#  geom_bar(stat ="identity")

in.counts <- c(nrow(in.both), nrow(in.mine.only), nrow(in.current.only))
#in.counts <- as_tibble(in.counts, counts = in.counts)
barplot(in.counts, names.arg = c("BOTH", "ME ONLY", "CURRENT ONLY"))

# I CAN'T GET THIS TO WORK...
#excluded.middle.counts <- c()
##count.both <- nrow(select(in.both, in.both$excluded.middle == "yes"))
##select(in.both, in.both$excluded.middle == "yes")
##count.both <- nrow(in.both$term01[in.both$term01 == "yes"])
##count.both <- in.both[which(in.both$excluded.middle == 'yes')]

#count.mine <- nrow(in.mine.only$term01[in.mine.only$term01 == "yes"])
#count.current <- nrow(in.current.only$term01[in.current.only$term01 == "yes"])
#excluded.middle.counts <- c(count.both, count.mine, count.current)

#barplot(excluded.middle.counts, names.arg = c("BOTH", "ME ONLY", "CURRENT ONLY"))
```

### For next weeks...

1. Test cases in human-readable form
2. Handle substitutions (e.g. hypercalcemia vs. hypocalcemia)
3. Failing test case: _protein folding_ versus _protein unfolding_
4. Failing test case: _name: oil gland decreased thickness_ versus _oil gland increased thickness_
4. Suffixes (e.g. hydrophilic vs. hydrophobic)
5. Consistent naming scheme for experimental-results directory
6. Word-internal, possibly (might produce a lot of false positives later when we do generation)
7. _See email exchange with Bill_

## 2021-04-21 report

Now handling:

1. Now handling morphological substitutions, as opposed to additions. That means that where we used to get only pairs like abnormal, where the contrast is between presence of ab and absence of ab, we now also get hypercalcemia/hypocalcemia, where the contrast is not presence/absence, but rather between two things that are... Shit, I'm tired of trying to squeeze this into non-technical language.  We used to only get prefix + free morpheme; now we are getting prefix + bound morpheme.  Honi soit qui mal y pense.

2. Now handling suffixes. So, we now get pairs like hydrophilic/hydrophobic (thanks to Leslie Rapp for that one). Embarrassingly, I am not getting leukemia/leukopenia--bug being hunted.

1. Test cases in human-readable form
2. Failing test case: _protein folding_ versus _p274rotein unfolding_
3. Failing test case: _name: oil gland decreased thickness_ versus _oil gland increased thickness_
4. Consistent naming scheme for experimental-results directory
5. _See email exchange with Bill_
6. Word-internal, possibly (might produce a lot of false positives later when we do generation)

## 2021-05-05 report

1. Took a week of vacation
2. Took a sick day
3. Generated the outputs for all of the CRAFT ontologies, plus HPO, MPO, and PATO

## 2021-05-26


```{r, eval = FALSE}
# only need to do once
#install.packages("entropy")
#library(entropy)

mi.calcs <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/TRANSLATOR opposites MI.tsv", header = TRUE, sep = "\t")

get.rid.of.commas <- function(input.vector) {
  output.vector <- gsub(",", "", input.vector)
  return(output.vector)
}

# preprocessing--some things need to be integers, others factors
mi.calcs$opposite <- factor(mi.calcs$opposite)
mi.calcs$x.count <- as.integer(get.rid.of.commas(mi.calcs$x.count))
mi.calcs$y.count <- as.integer(get.rid.of.commas(mi.calcs$y.count))
mi.calcs$y.minus.x.count <- as.integer(get.rid.of.commas(mi.calcs$y.minus.x.count))
mi.calcs$x.minus.y.count <- as.integer(get.rid.of.commas(mi.calcs$x.minus.y.count))
mi.calcs$xy.count <- as.integer(get.rid.of.commas(mi.calcs$xy.count))
as_tibble(mi.calcs)


#mi.calcs <- mi.calcs %>% mutate(p.x = (x.count / (x.count + y.minus.x.count))) %>% mutate(p.y = (y.count / (y.count + y.minus.x.count))) %>% mutate(p.xy = (xy.count / (xy.count + x.minus.y.count + y.minus.x.count))) %>% 
#mutate(mi.or.something = p.xy / (p.x * p.y)) 

#mi.calcs <- mi.calcs %>% mutate(p.x = x.count / (x.not.y.count + y.not.x.count + x.and.y.count))
#mi.calcs <- mi.calcs %>% mutate(p.x = x.count)
# calculate p(x)
mi.calcs <- mi.calcs %>% mutate(p.x = x.count / (x.minus.y.count + y.minus.x.count + xy.count))
# calculate p(y)
mi.calcs <- mi.calcs %>% mutate(p.y = y.count / (x.minus.y.count + y.minus.x.count + xy.count))
# calculate p(x,y)
mi.calcs <- mi.calcs %>% mutate(p.xy = xy.count / (x.minus.y.count + y.minus.x.count + xy.count))
mi.calcs <- mi.calcs %>% mutate(mi.or.something = p.xy / (p.x * p.y))

#mi.calcs$mi.or.something <- log(mi.calcs$mi.or.something)

# Here I plot the values on a scale from 0.0 to 1.0
ggplot(data = mi.calcs, mapping = aes(x = opposite, y = mi.or.something)) +
  geom_boxplot() +
  ylim(0, 1.0) + 
  #ylab("MI or something") + 
  labs(x = "Non-opposites versus opposites", y = "MI or something", title = "Like MI but not log")
  #names(c("Not opposites", "Opposites"))

shapiro.test(mi.calcs$mi.or.something)

# Here I plot their logs
mi.calcs$mi.or.something <- log(mi.calcs$mi.or.something)
ggplot(data = mi.calcs, mapping = aes(x = opposite, y = mi.or.something)) +
  geom_boxplot() +
  #ylim(0, 1.0) + 
  #ylab("MI or something") + 
  labs(x = "Non-opposites versus opposites", y = "MI or something", title = "MI (maybe)")
  #names(c("Not opposites", "Opposites"))

head(mi.calcs)
#mi.calcs$mi.or.something %>% gather(opposite)

#mi.calcs <- mi.calcs %>%  select(opposite, mi.or.something)
#head(mi.calcs)

#wilcox.test(select(mi.calcs$opposite == "0"), select(mi.calcs$opposite == "1"))
```

## Next step

Multi-word phrases, moving towards opposite sides of normal

HPO/MPO/MONDO terms with increase and decrease; then adjectival ones (especially hyper- and hypo-) (and generate more of those? Easy enough to do)

- Variability across those? Like, increased versus "increase in", "elevation of", etc.? Again, it's generation...


- Additional affixes: over- and under-

## 2021-06-02

1. Observation: synonymy is impoverished in these ontologies.  For example, _increased hemoglobin_ is probably equivalent to _elevated hemoglobin_, but only the first is in the ontology.
2. So, the data would benefit from Dr. Funking.
3. Logical opposites don't necessarily occur in these ontologies, and there might be good reasons for that. For example, _hypoxemia_ is a clearly clinically relevant concept, but _hyperoxemia_ might _not_ be.  This contrasts with _decreased hemoglobin affinity for oxygen_ and _increased hemoglobin affinity for oxygen_, both of which _are_ entirely clinically relevant.

Here are some numbers that support (1) and (3):

HPO contains:

- 459 non-obsolete terms with 'increased'
- 370 non-obsolete terms with 'decreased'
- 168 paired non-obsolete increased/decreased terms

This suggests that although perhaps there should _not_ be more pairs of opposites, there certainly _could_ be.

- 453 non-obsolete terms with 'hyper'
- 671 non-obsolete terms with 'hypo'
- 108 paired non-obsolete hypo/hyper terms

Again, this suggests that although perhaps there should _not_ be more pairs of opposites, there certainly _could_ be.

- 165 with 'reduced'
- 153 with 'elevated'
- 4 with 'depressed'
- 33 with 'high'
- 61 with 'low'

The 153:33 ratio of _elevated_ to _high_ and 165:4:61 of _reduced/depressed/low_ suggests that for recognition in text, Funkification would increase recall.

------------------------

So, for any given ontology, here's what I did:

1. Grep out the terms with _increase, decrease, hyper,_ or _hypo_.
2. Find the subset of those (increase/decrease and hyper/hypo) that do occur in addition to their logical opposite. (scripts: _increasedDecreasedOpposites.pl_ and _hyperHypoOpposites.pl_)
3. For that subset, generate synonyms for both members of the pair. (script: _generatePairs.pl_)

_Now let's go to a terminal..._


## 2021-06-09

I've updated the format of the files that contain opposites and synonyms. Now it encodes whether or not they're opposites, whether or not they're synonyms (you can be one, or the other, or neither, but not both); whether they're in the original form (i.e. exact match to the term in the ontology), or derived; and their source.

So, this code takes those and automates the searches that last week I was doing manually.
 
```{r}
library("easyPubMed")
files <- c("/Users/kevincohen/Downloads/TRANSLATOR opposites MI - PATO.tsv",
           "/Users/kevincohen/Downloads/TRANSLATOR opposites MI - HPO.tsv")

#sheet <- read.table("/Users/kevincohen/Downloads/TRANSLATOR opposites MI - PATO.tsv",
#                  header = TRUE, sep = "\t")

counts <- as.integer(c())
sheet <- data.frame()

for (file_number in 1:length(files)) {
  if (DEBUG) { print(paste("File:", files[file_number])) }  
  sheet <- NULL
  counts <- NULL
  # stupid name for the variable, derived from the fact that 
  # I made the files from different sheets of the same spreadsheet
  sheet <- data.frame()
  sheet <- read.table(files[file_number], header = TRUE, sep = "\t")
  sheet$opposites <- as.factor(sheet$opposites)
  sheet$synonyms <- as.factor(sheet$synonyms)
  
  #print(xtabs(~opposites+synonyms, data = sheet))
  print(ftable(xtabs(~opposites+synonyms, data = sheet)))

  # FOR DEV ONLY
  #sheet <- sheet[1:5, ]
  
  for (i in 1:nrow(sheet)) {
  #for (i in 1:5) {
 
    if (DEBUG) { print(paste("Row number:", i))}
    
    my_query <- paste('"', sheet[i, "term.01"], '"', " ",  '"', sheet[i, "term.02"], '"', sep = "")
    #my_query <- paste('"', sheet[i, "term.01"], '"', " ",  '"', sheet[i, "term.02"], sep = "")
    if (DEBUG) { print(my_query) } 
    my_entrez_id <- get_pubmed_ids(my_query)
    #print(my_entrez_id$Count)
    counts <- c(counts, as.integer(my_entrez_id$Count))
  } # loop through pairs of terms
  
  column.names <- colnames(sheet)
  if (DEBUG) { print("Add counts to data.frame")
            print(paste("Rows in data.frame:", nrow(sheet), "Elements in counts:", length(counts)))}
  sheet <- cbind(sheet,counts) 
  column.names <- c(column.names, "counts")
  if (DEBUG) { print("Reset column names") }
  colnames(sheet) <- column.names
  
  if (DEBUG) { print("Finally, generate the graph") }
  boxplot(sheet$counts ~ sheet$opposites,
          #main = files[file_number],
          main = paste(files[file_number], "OUTLIERS REMOVED"),
          outline = FALSE) # outline = FALSE removes outliers, of which there are quite a few
  
  # silly to do this while I barely have any synonyms, or non-opposites at all, really...
  #hypothesis.test <- wilcox.test(sheet$counts ~ sheet$opposites)
  #print(hypothesis.test)
  
} # close for-loop through list of files

#print(counts)

#boxplot(counts)
```

For next week:

1. Add the searches for the four conditions that the code doesn't cover yet. Right now, it only does the search for term.01 & term.02. Need to add these four:
  a. term.01 
  b. term.01 - term.02
  c. term.02 
  d. term.02 - term.01
2. Automatic generation of synonyms needs to be rewritten for new file format.
3. New file for MONDO.
4. Classify opposites by type of opposition.  Hypothesis: can do some of that programmatically.

## For reproducibility
```{r, echo = FALSE}
sessionInfo()
```

