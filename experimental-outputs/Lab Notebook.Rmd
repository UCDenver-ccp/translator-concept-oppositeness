---
title: "Lab notebook"
author: "KBC"
date: "4/5/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggVennDiagram)

DEBUG <- FALSE
```

## 2021-04-05 report


## Utility functions

```{r, echo = FALSE}
# arguments:
# an ontology object
# a list of IDs to look up and print the corresponding terms
print_opposites <- function(this.ontology, opposite.ids) {
  for (i in 1:nrow(opposite.ids)) {
    opposites <- opposite.ids[i,]
    id01 <- as.character(opposite.ids[1])
    id02 <- as.character(opposite.ids[2])
    term01 <- get_term_property(this.ontology, property = "name", term = id01)
    term02 <- get_term_property(this.ontology, property = "name", term = id02)
    print(paste(term01, term02, sep = "     "))
  }
} # close function definition print_opposites
  
```


## Opposites already manually paired 

Bill can explain where these came from better than I can.

```{r, echo = FALSE, eval = FALSE}

# NB: need to add reduce/increase. Do HP, then RO.

# only found by me
# comm -23 experimental-outputs/pato.mine.terms.only.tsv resources/current-opposites.sorted.terms.only.tsv | wc -l
#      59

# only in current annotations
#comm -13 experimental-outputs/pato.mine.terms.only.tsv resources/current-opposites.sorted.terms.only.tsv | wc -l
#      27


# in both
#comm -12 experimental-outputs/pato.mine.terms.only.tsv resources/current-opposites.sorted.terms.only.tsv | wc -l
#     188

# https://www.datanovia.com/en/fr/blog/magnifique-diagramme-de-venn-ggplot-avec-r/

# this separates out the three entirely--not what the ggVennDiagram() function is looking for
# Here I'm just getting the terms themselves in printable fashion, separating them by who "finds" them
pato.mine.only <- as.vector(read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/pato.in.mine.txt"))
pato.mine.only <- stringr::str_split(pato.mine.only, pattern = "\t")
#pato.mine.only
current.only <- as.vector((read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/pato.in.current.txt")))
current.only <- stringr::str_split(current.only, pattern = "\t")
both.mine.and.current <- as.vector((read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/pato.in.both.txt")))
both.mine.and.current <- stringr::str_split(both.mine.and.current, pattern = "\t")

# here I have *everything* that I found and *everything* in current, so that we can quantify overlap & lack thereof
pato.mine <- as.vector(read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/pato.mine.terms.only.tsv"))
current <- as.vector(read_lines("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/resources/current-opposites.sorted.terms.only.tsv")) # includes two non-PATO terms

x <- list(Mine = pato.mine, Current = current)
ggVennDiagram(x)

print("IN BOTH MINE AND THE CURRENT PAIRS:")
#print(both.mine.and.current, row.names = FALSE)
for (i in 1:length(both.mine.and.current)) { print(both.mine.and.current[[i]])}
print("")

print("IN MINE ONLY:") 
for (i in 1:length(pato.mine.only)) { print(pato.mine.only[[i]])}
print("")

print("IN THE CURRENT PAIRS ONLY:")
for (i in 1:length(current.only)) { print(current.only[[i]])}




```


## Comparison to Chris et al.'s stuff

```{r, echo = FALSE}
chris <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/mungall_both_hp.tsv", header = FALSE, sep = "\t")
colnames(chris) <- c("term01", "term02")
chris <- as_tibble(chris)
hp.mine <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/hp_opposites_ids_only.tsv", header = FALSE, sep = "\t")
colnames(hp.mine) <- c("term01", "term02")
hp.mine <- as_tibble(hp.mine)

# Reran my stuff on HPO 2021-04
chris.as.vector <- as.vector(paste(chris$term01, chris$term02))
hp.mine.as.vector <- as.vector(paste(hp.mine$term01, hp.mine$term02))
x <- list(Mine = hp.mine.as.vector, Chris = chris.as.vector)
ggVennDiagram(x)

print("Mine:")
print(hp.mine)
print("Chris's:")
print(chris)
```
OK, we know the intersection/complements, so let's see what Chris's opposites look like, exactly.

```{r, echo = FALSE}
library(ontologyIndex)
# His data is IDs only, and we need the terms, so we need to have a searchable version of HPO.
hpo.ontology <- get_ontology("/Users/kevincohen/Dropbox/a-m/Corpora/obo/hp-2020-20-12.obo")

# REDUNDANT, I THINK??
# for (i in 1:nrow(chris)) {
#   #print(chris[i,])
#   opposites <- chris[i,]
#   id01 <- as.character(opposites[1])
#   id02 <- as.character(opposites[2])
#   term01 <- get_term_property(hpo.ontology, property = "name", term = id01)
#   term02 <- get_term_property(hpo.ontology, property = "name", term = id02)
#   print(paste(term01, term02, sep = "     "))
#   # term01 <- chris[i,]
#   # term02 <- chris[i,]
# }

intersection.ids <- intersect(hp.mine, chris)
if (DEBUG) { print(intersection.ids) }

print("FOUND BY BOTH ME AND CHRIS:")
for (i in 1:nrow(intersection.ids)) {
  opposites <- intersection.ids[i,]
  id01 <- as.character(opposites[1])
  id02 <- as.character(opposites[2])
  term01 <- get_term_property(hpo.ontology, property = "name", term = id01)
  term02 <- get_term_property(hpo.ontology, property = "name", term = id02)
  print(paste(term01, term02, sep = "     "))
}

mine.only.ids <- setdiff(hp.mine, chris)
chris.only.ids <- setdiff(chris, hp.mine)

# TODO: could make term-only tibbles here
print("FOUND BY ME, NOT BY CHRIS:")
print("")
for (i in 1:nrow(mine.only.ids)) {
  opposites <- mine.only.ids[i,]
  id01 <- as.character(opposites[1])
  id02 <- as.character(opposites[2])
  term01 <- get_term_property(hpo.ontology, property = "name", term = id01)
  term02 <- get_term_property(hpo.ontology, property = "name", term = id02)
  print(paste(term01, term02, sep = "     "))
}

print("FOUND BY CHRIS, NOT BY ME:")
print("")
for (i in 1:nrow(chris.only.ids)) {
  opposites <- chris.only.ids[i,]
  id01 <- as.character(opposites[1])
  id02 <- as.character(opposites[2])
  term01 <- get_term_property(hpo.ontology, property = "name", term = id01)
  term02 <- get_term_property(hpo.ontology, property = "name", term = id02)
  print(paste(term01, term02, sep = "     "))
}


```

## RO exploration 

I extracted the terms from the current version of the RO, then got the absolute frequencies of their words:

_/Users/kevincohen/Dropbox/Scripts-new/lexicalFrequency.pl experimental-outputs/ro.terms.txt
_

...which reveals imbalances in the use of words that are clear opposites, e.g.:

* during	11 before	4 after	2
* to	49 from	16 towards	1 _how about away?_
* directly	18 indirectly	8
* indirect	2 direct	2

...which suggests that I could be adding a bunch of opposite terms to the ontology.

So, I ran the current version of my antonym-finding script:

_code/findAntonyms.pl resources/ontologies/ro.2021-03-08.obo.txt |wc -l _

...which finds 43 pairs of opposites.

Next step: find overlap with Mike's resources/ontologies/predicates.txt.

## For next weeks...

0. With Bill, reorganize repository and merge with TRANSLATOR's
1. Test cases in human-readable form
2. Handle substitutions (e.g. hypercalcemia vs. hypocalcemia)
3. Suffixes (e.g. hydrophilic vs. hydrophobic)
4. Word-internal, possibly (might produce a lot of false positives later when we do generation)

## 2021-04-15 report

### Analysis of PATO opposites WRT the excluded middle

Motivation: this picks out a specific type of opposition: what Pustejovsky calls _polar_, meaning that there's a scale and the things at the two poles of the scale are opposites of each other.

### How I assigned the excluded.middle value

0. If the middle is reasonably clearly excluded, I assigned the value _yes_. Examples: _acute/chronic, aerobic/anaerobic_. If that is not the case, then I put the "middle" value in the excluded.middle field. Example: for _phosphorylated/dephosphorylated_, I put the value _unphosphorylated_ in the excluded.middle column.

1. Almost every pair that fits the pattern _increased/decreased x_ has a mid-point or neutral point _normal x_.
2. Most pairs of the form _x/unx_ (e.g. _responsive/unresponive_) exclude the middle. Exception: _damaged/undamaged/repaired_.
3. Most pairs of the form _x/dex_ (e.g. _phosphorylated/dephosphorylated_) have a neutral point _unx_ (e.g. _unphosphorylated_). 
4. Most pairs of the form _hypox/hyperx_ where both members of the pair are single words have a single-word neutral point _normox_. For example, for the pair _hypotrophic/hypertrophic_, there is a neutral point _normotrophic_. If I had any question about the legitimacy of these, I checked Google Scholar to ensure that the _normox_ word is used.
5. If I did not find such a word via Google Scholar, then I searched for the phrase _neither term01 nor term02_. If I found it, then I put the phrase in the field. (TODO: now that I think about it, if I didn't find the phrase, I didn't try again with the order _term02 term01_. Need to do that.)

```{r}
# "current" is the ones that Bill found currently in use
in.both <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/typed.opposites.pato.in.both.txt", header = TRUE, sep = "\t")
in.mine.only  <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/typed.opposites.pato.in.mine.txt", header = TRUE, sep = "\t")
in.current.only <- read.table("/Users/kevincohen/Dropbox/N-Z/translator-concept-oppositeness/experimental-outputs/typed.opposites.pato.in.current.txt", header = TRUE, sep = "\t")

in.both$excluded.middle <- as.character(in.both$excluded.middle)
in.mine.only$excluded.middle <- as.character(in.mine.only$excluded.middle)
in.current.only$excluded.middle <- as.character(in.current.only$excluded.middle)
# in.both <- as_tibble(in.both)
# in.both <- mutate(in.both, found.by = "BOTH")
# in.mine.only <- as_tibble(in.mine.only)
# in.mine.only <- mutate(in.mine.only, found.by = "ME")
# in.current.only <- as_tibble(in.current.only)
# in.current.only <- mutate(in.current.only, found.by = "CURRENT")
 
# in.combined <- as_tibble(in.both, in.mine.only, in.current.only)

#ggplot(data = in.combined, mapping = aes(x = found.by, )) +
#  geom_bar(stat ="identity")

in.counts <- c(nrow(in.both), nrow(in.mine.only), nrow(in.current.only))
#in.counts <- as_tibble(in.counts, counts = in.counts)
barplot(in.counts, names.arg = c("BOTH", "ME ONLY", "CURRENT ONLY"))

# I CAN'T GET THIS TO WORK...
#excluded.middle.counts <- c()
##count.both <- nrow(select(in.both, in.both$excluded.middle == "yes"))
##select(in.both, in.both$excluded.middle == "yes")
##count.both <- nrow(in.both$term01[in.both$term01 == "yes"])
##count.both <- in.both[which(in.both$excluded.middle == 'yes')]

#count.mine <- nrow(in.mine.only$term01[in.mine.only$term01 == "yes"])
#count.current <- nrow(in.current.only$term01[in.current.only$term01 == "yes"])
#excluded.middle.counts <- c(count.both, count.mine, count.current)

#barplot(excluded.middle.counts, names.arg = c("BOTH", "ME ONLY", "CURRENT ONLY"))
```

### For next weeks...

1. Test cases in human-readable form
2. Handle substitutions (e.g. hypercalcemia vs. hypocalcemia)
3. Failing test case: _protein folding_ versus _protein unfolding_
4. Failing test case: _name: oil gland decreased thickness_ versus _oil gland increased thickness_
4. Suffixes (e.g. hydrophilic vs. hydrophobic)
5. Consistent naming scheme for experimental-results directory
6. Word-internal, possibly (might produce a lot of false positives later when we do generation)
7. _See email exchange with Bill_


## For reproducibility
```{r, echo = FALSE}
sessionInfo()
```

